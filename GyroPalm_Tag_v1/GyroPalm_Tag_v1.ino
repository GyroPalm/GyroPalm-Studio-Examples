/*
*	Test Activation Gesture (TAG) v1 is an example project for an activation gesture 
*	that triggers when a user performs a snap when wrist upside-down and glances.
*
*   To perform gesture, do the following:
*   1. Invert hand (palm facing up)
*   2. Do a quick snap (vibration if successful)
*   3. Glance at the watch (long vibration if successful)
*
*   The LED will turn on once activated. The 'isActive' boolean will remain true.
*   If your app needs auto-timeout deactivation, set autoTimeout to true. 
*   Then 'isActive' will return false in 8 seconds.
*/

// Begin AutoGenerated Includes - DO NOT EDIT BELOW
#include <GyroPalmEngine.h>
#include <GyroPalmLVGL.h>
// End AutoGenerated Includes - DO NOT EDIT ABOVE

// Begin AutoGenerated Globals - DO NOT EDIT BELOW
GyroPalm *device;
GyroPalmEngine gplm("gp123456");    //declares a GyroPalm Engine object with wearableID

AXP20X_Class *power;
lv_task_t *barTask;
void lv_update_task(struct _lv_task_t *);
lv_task_t* activationTask;
void lv_activation_task(struct _lv_task_t *);

enum Screen { SCR_HOME };	//Screen indexes
lv_obj_t *screen[1];    //screen pointers
GyroPalmLVGL form[1];   //screen helper methods
Screen curScreen = SCR_HOME;    //default screen
// End AutoGenerated Globals - DO NOT EDIT ABOVE

lv_obj_t * led;
bool isActive = false;
long lastActive = 0;
bool autoTimeout = false;   //change this to true if you want auto deactivation
long lastFlipped = 10000;
long lastSnapped = 0;

// Begin AutoGenerated Callbacks - DO NOT EDIT BELOW
void lv_update_task(struct _lv_task_t *data) {
    int battPercent = power->getBattPercentage();
    bool isCharging = power->isChargeing();
    form[curScreen].updateBar(battPercent, isCharging);
    form[curScreen].setTime(gplm.getTime());     //update Time View
}

static void btn_event_handler(lv_obj_t * obj, lv_event_t event)
{
    if (event == LV_EVENT_CLICKED) {
        String btnName = lv_list_get_btn_text(obj);
		Serial.printf("Clicked: %s\n", btnName);

        switch (curScreen)
        {
            case SCR_HOME:
			if (btnName == "Reset") {
                isActive = false;
            }
            break;

            default: break;
		}
	}
}
// End AutoGenerated Callbacks - DO NOT EDIT ABOVE

void lv_activation_task(struct _lv_task_t *data) {
    if (isActive) {
        lv_led_on(led);
    } else {
        lv_led_off(led);
    }

    if (autoTimeout && (millis() - lastActive >= 8000)) isActive = false;
}

void onPwrQuickPress()
{
    /*
    After the AXP202 interrupt is triggered, the interrupt status must be cleared,
    * otherwise the next interrupt will not be triggered
    */
    power->clearIRQ();

    // We are sleeping the device when power button pressed
    device->displaySleep();
    device->powerOff();
    esp_sleep_enable_ext1_wakeup(GPIO_SEL_35, ESP_EXT1_WAKEUP_ALL_LOW);
    esp_deep_sleep_start();
}

void onDeviceTilt(int direction)
{
    if (direction == TILT_UPSIDEDOWN) {
        lastFlipped = millis();
    }
}

void onRawSnap()
{
    lastSnapped = millis();
    if (lastSnapped > lastFlipped && abs(lastSnapped - lastFlipped) < 1500) {
        gplm.vibrateTap();
    }
}

void onGlance(bool isGlanced)
{
    if (isGlanced) {
        form[curScreen].showIcon(BAR_GLANCE);
        lv_disp_trig_activity(NULL);    //trigger user activity
        if (millis() - lastSnapped < 2500) {    //if isGlanced happened less than 2.5 sec after snap
            if (lastSnapped > lastFlipped && abs(lastSnapped - lastFlipped) < 1500) {
                //flip happened first and snap happened less than 1.5 sec afterward
                gplm.vibrateHold();
                isActive = true;
                lastActive = millis();
            }
        }
    } else {
        form[curScreen].hideIcon(BAR_GLANCE);
    }
}

// Begin AutoGenerated Screens - DO NOT EDIT BELOW
void showApp(int page) {
    if ((Screen) page != curScreen) {
        form[curScreen].removeBar();    //remove old StatusBar before proceeding
    }

    switch (page)
    {
		case SCR_HOME:
        {
            //Draw screen UI
            curScreen = (Screen) page;
            form[curScreen].init(screen[curScreen]);  //now defining screen items
            form[curScreen].createBar(barTask, lv_update_task);
            form[curScreen].setTime(gplm.getTime());
			form[curScreen].createLabel(0, -37, "TAG v1");    //show element
			form[curScreen].createButton(-58, 67, "Reset", btn_event_handler, true, 98);    //show element
			led = form[curScreen].createLED(58, 67, false);    //show element

            form[curScreen].showScreen(ANIM_NONE);   //show the screen w/ no animation
        }
        break;


        default: break;
    }
}
// End AutoGenerated Screens - DO NOT EDIT ABOVE

void setup() {
	
    // Begin AutoGenerated Setup - DO NOT EDIT BELOW
	gplm.begin();
	delay(100);
	gplm.listenEvents(false);    //starts listening for events

    // Include only the callbacks you need:
    gplm.setTiltCallback(onDeviceTilt);
    gplm.setRawSnapCallback(onRawSnap);
    gplm.setGlanceCallback(onGlance);
    gplm.setPwrQuickPressCallback(onPwrQuickPress);
    delay(200);

	device = gplm.wearable; //gives control to the developer to run device methods
	device->lvgl_begin();   //Initiate LVGL core
	device->bl->adjust(120);    //Lower the brightness
	power = gplm.power;		//gives control to the developer to access power methods
	power->setChargeControlCur(500);    //enable fast charging

	showApp(curScreen);
	// End AutoGenerated Setup - DO NOT EDIT ABOVE

    activationTask = lv_task_create(lv_activation_task, 500, LV_TASK_PRIO_LOWEST, NULL); //run task every half-second
}

void loop() {
	
    // Begin AutoGenerated Loop - DO NOT EDIT BELOW
	lv_task_handler();
	delay(50);
	// End AutoGenerated Loop - DO NOT EDIT ABOVE
}
