// Begin AutoGenerated Includes - DO NOT EDIT BELOW
#include <GyroPalmEngine.h>
#include <GyroPalmLVGL.h>
// End AutoGenerated Includes - DO NOT EDIT ABOVE
#include <GyroPalmESPNOW.h>

GyroPalmESPNOW gpwireless(ESPNOWrole::SERVER);
String clientAddress;

// A struct to organize data to send
// CANNOT BE > 256 BYTES
typedef struct struct_message {
  char wearableID[30];
  char action[30];
  int x;
  int y;
} struct_message;

// Begin AutoGenerated Globals - DO NOT EDIT BELOW
GyroPalm *device;
GyroPalmEngine gplm("gp123456");    //declares a GyroPalm Engine object with wearableID

AXP20X_Class *power;
lv_task_t *barTask;
void lv_update_task(struct _lv_task_t *);

lv_task_t* driveTask;
void lv_drive_task(struct _lv_task_t *);

enum Screen { SCR_HOME };	//Screen indexes
lv_obj_t *screen[1];    //screen pointers
GyroPalmLVGL form[1];   //screen helper methods
Screen curScreen = SCR_HOME;    //default screen
// End AutoGenerated Globals - DO NOT EDIT ABOVE



bool isDriving = false;

lv_obj_t *btnUndock;
lv_obj_t *btnDock;
lv_obj_t *btnUturn;
lv_obj_t *lblStatus;

lv_obj_t *msgboxRead;

void showMsg(String msg) {
    msgboxRead = form[curScreen].createMsgBox((char *)msg.c_str(), PROMPT_OK, msgbox_handler, true);
}

static void msgbox_handler(lv_obj_t *obj, String btnText)
{
    if (obj == msgboxRead) {
        Serial.println("Response from MsgBox A");
        msgboxRead = NULL;
    }
    Serial.print("User response: ");
    Serial.println(btnText);
}

bool sendDockCommand(bool undock)
{
    struct_message myData;

    if (undock) {
        strcpy(myData.wearableID, gplm.myLicense.wearableID);
        strcpy(myData.action, "srundock");
        myData.x = 0;
        myData.y = 0;
    } else {
        strcpy(myData.wearableID, gplm.myLicense.wearableID);
        strcpy(myData.action, "srdock");
        myData.x = 0;
        myData.y = 0;
    }
    return(gpwireless.sendMessage((uint8_t *)&myData, sizeof(myData), clientAddress));
}

bool sendDriveCommand()
{
    struct_message myData;
    strcpy(myData.wearableID, gplm.myLicense.wearableID);
    strcpy(myData.action, "srdrive");
    myData.x = gplm.ax;
    myData.y = gplm.ay;
    
    return(gpwireless.sendMessage((uint8_t *)&myData, sizeof(myData), clientAddress));
}

bool sendUturnCommand()
{
    struct_message myData;
    strcpy(myData.wearableID, gplm.myLicense.wearableID);
    strcpy(myData.action, "sruturn");
    myData.x = 0;
    myData.y = 0;
    
    return(gpwireless.sendMessage((uint8_t *)&myData, sizeof(myData), clientAddress));
}

bool sendStateCommand(bool isStart)
{
    struct_message myData;

    if (isStart) {  //put robot in safe mode
        strcpy(myData.wearableID, gplm.myLicense.wearableID);
        strcpy(myData.action, "srstart");
        myData.x = 0;
        myData.y = 0;
    } else {    //tell robot to stop responding to commands
        strcpy(myData.wearableID, gplm.myLicense.wearableID);
        strcpy(myData.action, "srstop");
        myData.x = 0;
        myData.y = 0;
    }
    return(gpwireless.sendMessage((uint8_t *)&myData, sizeof(myData), clientAddress));
}

void OnSendError(uint8_t* ad)
{
  Serial.println("SENDING TO '"+gpwireless.macToStr(ad)+"' WAS NOT POSSIBLE!");
}

void OnPaired(uint8_t *ga, String ad)
{
  Serial.println("EspNowConnection : Client '"+ad+"' paired! ");
  gpwireless.endPairing();
  
  clientAddress = ad;
}

void OnConnected(uint8_t *ga, String ad)
{
  Serial.println("EspNowConnection : Client '"+ad+"' connected! ");
}

// Begin AutoGenerated Callbacks - DO NOT EDIT BELOW
void lv_update_task(struct _lv_task_t *data) {
    int battPercent = power->getBattPercentage();
    bool isCharging = power->isChargeing();
    form[curScreen].updateBar(battPercent, isCharging);
    form[curScreen].setTime(gplm.getTime());     //update Time View
}

static void btn_event_handler(lv_obj_t * obj, lv_event_t event)
{
    if (event == LV_EVENT_CLICKED) {
        String btnName = lv_list_get_btn_text(obj);
		Serial.printf("Clicked: %s\n", btnName);

        switch (curScreen)
        {
            case SCR_HOME:
                if (btnName == "Undock") {
                    sendDockCommand(true);  //undock
                    showMsg("Undock sent!");
                }
                else if (btnName == "Dock") {
                    sendDockCommand(false);  //dock
                    showMsg("Dock sent!");
                }
                else if (btnName == "Uturn") {
                    sendUturnCommand();
                    showMsg("Uturn sent!");
                }
            break;

            default: break;
		}
	}
}

// End AutoGenerated Callbacks - DO NOT EDIT ABOVE

// Begin AutoGenerated Screens - DO NOT EDIT BELOW
void showApp(int page) {
    if ((Screen) page != curScreen) {
        form[curScreen].removeBar();    //remove old StatusBar before proceeding
    }

    switch (page)
    {
		case SCR_HOME:
        {
            //Draw screen UI
            curScreen = (Screen) page;
            form[curScreen].init(screen[curScreen]);  //now defining screen items
            form[curScreen].createBar(barTask, lv_update_task);
            form[curScreen].setTime(gplm.getTime());
			form[curScreen].createLabel(0, -54, "OmniBot Control");    //show element
			lblStatus = form[curScreen].createLabel(0, 15, "Status: Standy");    //show element

			btnUndock = form[curScreen].createButton(-77, 84, "Undock", btn_event_handler, true, 59);    //show element
			btnDock = form[curScreen].createButton(0, 84, "Dock", btn_event_handler, true, 59);    //show element
			btnUturn = form[curScreen].createButton(77, 84, "Uturn", btn_event_handler, true, 59);    //show element

            form[curScreen].showScreen(ANIM_NONE);   //show the screen w/ no animation
        }
        break;


        default: break;
    }
    gplm.setScreen(&form[curScreen]);
}
// End AutoGenerated Screens - DO NOT EDIT ABOVE

void onPwrQuickPress()
{
    /*
    After the AXP202 interrupt is triggered, the interrupt status must be cleared,
    * otherwise the next interrupt will not be triggered
    */
    power->clearIRQ();

    // We are sleeping the device when power button pressed
    device->displaySleep();
    device->powerOff();
    esp_sleep_enable_ext1_wakeup(GPIO_SEL_35, ESP_EXT1_WAKEUP_ALL_LOW);
    esp_deep_sleep_start();
}

void onGlance(bool isGlanced)
{
    if (gplm.isActive == false) {   //only takes effect if wearable not active
        if (isGlanced) {
            form[curScreen].showIcon(BAR_GLANCE);
        } else {
            form[curScreen].hideIcon(BAR_GLANCE);
        }
    }
}

void onActivation(bool isActive)
{
    if (isActive) {
        Serial.println("Activated!");
        form[curScreen].setIconColor(BAR_GLANCE, LV_COLOR_CYAN);
        // your code here, once wearable is activated
    } else {
        Serial.println("Deactivated!");
        form[curScreen].setIconColor(BAR_GLANCE, LV_COLOR_WHITE);
        form[curScreen].hideIcon(BAR_GLANCE);
        // your code here, once wearable is deactivated
    }
}

void setDriving(bool stat)
{
    isDriving = stat;
    sendStateCommand(stat);
    if (stat) {
        lv_label_set_text(lblStatus, "Status: Drive");
    } else {
        lv_label_set_text(lblStatus, "Status: Standby");
    }
}

void onDeviceTilt(int direction)
{
    if (direction == LH_UPSIDEDOWN) {
        gplm.setActive(false);  //disable control since user performed hand-drop gesture
        setDriving(false);   //send stop driving intent
    }

    //only for activated commands --------------

    if (gplm.isActive != true) { // Ignore event if gesture performed without activation
        return;
    }

    switch(direction)
    {
        case LH_LEFT:
            gplm.setActive(false);  // Action completed, redeem activation
            setDriving(true);   //send start driving intent
        break;

        case LH_RIGHT:
            gplm.setActive(false);  // Action completed, redeem activation
            lv_event_send(btnDock, LV_EVENT_CLICKED, NULL); //dock requested
        break;

        default: 
            gplm.setActive(false);  // Action completed, redeem activation
        break;
    }
}

//Insert this before:
void lv_drive_task(struct _lv_task_t *data) {
    
    if (isDriving) {
        sendDriveCommand();
    }
}

void setup() {

    // Begin AutoGenerated Setup - DO NOT EDIT BELOW
	gplm.begin();
	delay(100);
	gplm.listenEvents(false);    //starts listening for events

    gplm.setGlanceCallback(onGlance);   // use onGlance as a helper
    gplm.setPwrQuickPressCallback(onPwrQuickPress);
    gplm.setTiltCallback(onDeviceTilt); // use onDeviceTilt as a navigation gesture
    delay(100);

    gplm.autoTimeout = true;    //tells the wearable to deactivate automatically
    gplm.deactivateTimeout = 3000;  // (optional) timeout in miliseconds (3 seconds default)
    gplm.activationGesture = ACT_DOUBLE_SNAP;   // (optional) ACT_DOUBLE_SNAP by default
    gplm.setActivationCallback(onActivation);   // register activation gesture callback

	device = gplm.wearable; //gives control to the developer to run device methods
	device->lvgl_begin();   //Initiate LVGL core
	device->bl->adjust(120);    //Lower the brightness
	power = gplm.power;		//gives control to the developer to access power methods
	power->setChargeControlCur(500);    //enable fast charging

	showApp(curScreen);
	// End AutoGenerated Setup - DO NOT EDIT ABOVE


    //clientAddress = "409151449602";
    clientAddress = "FFFFFFFFFFFF";
    gpwireless.begin();
    gpwireless.onPaired(&OnPaired);  
    gpwireless.onSendError(&OnSendError);
    gpwireless.onConnected(&OnConnected);  

    //Serial.println(WiFi.macAddress());
    //gpwireless.startPairing(30);

    Serial.println("Performing self calibration");
    gplm.doCalibration(10);
    Serial.println("Calibration complete");

    driveTask = lv_task_create(lv_drive_task, 80, LV_TASK_PRIO_LOWEST, NULL); //run task every 1 seconds
}

void loop() {
    gpwireless.loop();

    // Begin AutoGenerated Loop - DO NOT EDIT BELOW
	lv_task_handler();
	delay(30);
	// End AutoGenerated Loop - DO NOT EDIT ABOVE
}
